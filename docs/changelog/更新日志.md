# 更新日志

## 最新修复 - 2025-10-22

### 🐛 修复问题

**YOLO工具箱加载失败修复**
- 问题描述：应用启动时出现 `YOLO工具箱加载失败: name 'QSlider' is not defined` 错误
- 原因：在 <mcfile name="yolo_ui.py" path="YOLO/yolo_ui.py"></mcfile> 文件中使用了QSlider控件但未在导入语句中添加
- 解决方案：在PyQt6.QtWidgets导入列表中添加QSlider
- 修复代码：
```python
from PyQt6.QtWidgets import (
    # ... 其他导入 ...
    QGridLayout, QProgressDialog, QSizePolicy, QSlider  # 添加QSlider
)
```
- 影响范围：YOLO工具箱的所有使用滑块控件的页面

## v1.5 - 2025-10-20

### ✨ 新增功能

#### 标题栏右侧功能图标

在标题栏右侧（原窗口控制按钮位置）添加了三个功能图标：

1. **💬 通知按钮**
   - 图标：聊天/消息图标
   - 功能：点击显示通知提示
   - 提示："您有 0 条未读通知"

2. **⚙️ 设置按钮**
   - 图标：设置齿轮图标
   - 功能：点击跳转到设置页面
   - 快捷访问设置功能

3. **👤 用户头像**
   - 组件：圆形头像
   - 功能：点击显示用户菜单
   - 菜单选项：个人信息、切换账号、退出登录

### 📝 代码变更

**新增组件导入**：
```python
from qfluentwidgets import (
    TransparentToolButton,  # 透明工具按钮
    Action,                 # 菜单动作
    AvatarWidget           # 头像组件
)
```

**CustomTitleBar 扩展**：
```python
# 添加功能按钮
self.notificationBtn = TransparentToolButton(FIF.CHAT, self)
self.settingsBtn = TransparentToolButton(FIF.SETTING, self)
self.avatar = AvatarWidget(parent=self)

# 添加到布局
self.hBoxLayout.addWidget(self.notificationBtn, 0, Qt.AlignmentFlag.AlignRight)
self.hBoxLayout.addWidget(self.settingsBtn, 0, Qt.AlignmentFlag.AlignRight)
self.hBoxLayout.addWidget(self.avatar, 0, Qt.AlignmentFlag.AlignRight)

# 连接点击事件
self.settingsBtn.clicked.connect(self._onSettingsClicked)
self.notificationBtn.clicked.connect(self._onNotificationClicked)
self.avatar.clicked.connect(self._onAvatarClicked)
```

### 🎯 界面效果

#### 标题栏布局
```
┌──────────────────────────────────────────────────────────────┐
│ [图标] [标题]  [━━━ 搜索框 ━━━]   [💬] [⚙️] [👤]              │
└──────────────────────────────────────────────────────────────┘
```

### ✨ 交互功能

- ✅ **通知按钮**：显示信息提示条
- ✅ **设置按钮**：快速跳转设置页面
- ✅ **用户头像**：弹出用户菜单（个人信息、切换账号、退出登录）

### 💡 可扩展性

- 可设置真实的用户头像
- 可连接到实际的通知系统
- 可添加更多功能按钮
- 可自定义菜单内容

详细说明请查看：[v1.5更新说明.md](v1.5更新说明.md)

---

## v1.4.1 - 2025-10-20

### 🐛 Bug 修复

#### 修复导航栏展开遗挡图标问题
**问题描述**：
- 在 v1.4 中，导航栏在初始化时立即展开
- 由于窗口布局还未完全准备好，导致展开的导航栏遗挡了窗口图标

**修复方案**：
- 使用 `QTimer.singleShot(100, ...)` 延迟 100ms 展开导航栏
- 确保窗口布局完成、最大化显示后再执行展开操作
- 新增 `_expandNavigation()` 方法单独处理导航栏展开逻辑

### 📝 代码变更

#### 导入 QTimer
```python
from PyQt6.QtCore import Qt, QSize, QTimer
```

#### 修改 initWindow() 方法
```python
def initWindow(self):
    # ... 原有代码 ...
    
    self.show()
    QApplication.processEvents()
    
    # 窗口默认最大化
    self.showMaximized()
    
    # 延迟展开导航栏，确保布局完成后再展开
    QTimer.singleShot(100, self._expandNavigation)
```

#### 新增 _expandNavigation() 方法
```python
def _expandNavigation(self):
    """ 延迟展开导航栏 """
    self.navigationInterface.setExpandWidth(300)
    self.navigationInterface.expand(useAni=False)
```

### ✨ 效果改进

#### 修复前
```
启动 → 窗口显示 → 导航栏立即展开 → ⚠️ 遗挡图标
```

#### 修复后
```
启动 → 窗口显示 → 最大化 → 等待100ms → 导航栏展开 → ✅ 显示正常
```

### 🎯 测试验证

- [x] 窗口正常最大化
- [x] 导航栏正常展开
- [x] 窗口图标正常显示，未被遗挡
- [x] 导航项文字完整可见
- [x] 布局整齐，无视觉闪烁

### 💡 技术说明

**为什么需要延迟？**

1. **布局时序**：
   - `show()` 后，窗口布局还在计算中
   - `showMaximized()` 需要时间重新计算布局
   - 如果立即展开导航栏，会使用错误的布局尺寸

2. **100ms 延迟的原因**：
   - 给予 Qt 足够的时间完成窗口最大化和布局计算
   - 100ms 对用户几乎不可感知
   - 确保导航栏展开时使用正确的窗口尺寸

3. **useAni=False 的作用**：
   - 禁用展开动画，直接显示展开状态
   - 避免动画过程中的视觉闪烁

---

## v1.4 - 2025-10-20

### ✨ 界面优化

#### 窗口默认最大化
- ✅ 应用启动后自动全屏显示
- ✅ 提供更大的工作区域
- ✅ 沉浸式工作体验

#### 导航栏默认展开
- ✅ 侧边导航栏启动时自动展开
- ✅ 展开宽度设置为 300px
- ✅ 所有导航项文字完全可见
- ✅ 不使用展开动画，直接显示

#### 移除窗口控制按钮
- ✅ 隐藏最小化按钮
- ✅ 隐藏最大化按钮
- ✅ 隐藏关闭按钮
- ✅ 更简洁的标题栏
- ✅ 可通过 Alt+F4 或任务栏关闭窗口

### 📝 代码变更

**CustomTitleBar**：
```python
# 隐藏窗口控制按钮
self.minBtn.hide()
self.maxBtn.hide()
self.closeBtn.hide()
```

**Window.initWindow()**：
```python
# 窗口默认最大化
self.showMaximized()

# 导航栏默认展开
self.navigationInterface.setExpandWidth(300)
self.navigationInterface.expand(useAni=False)
```

### 🎯 用户体验提升

- ⚡ 启动即全屏，无需手动调整
- 📋 导航栏完全展开，功能一目了然
- 🎨 无按钮干扰，界面更简洁
- 💻 充分利用屏幕空间

详细说明请查看：[v1.4更新说明.md](v1.4更新说明.md)

---

## v1.3.1 - 2025-10-20

### 🐛 Bug 修复

#### 恢复搜索框功能
**问题描述**：
- 在 v1.3 迁移到 FluentWindow 后，标题栏的搜索框丢失

**修复方案**：
- 创建 `CustomTitleBar` 类，继承自 `FluentTitleBar`
- 在标题栏中添加 `SearchLineEdit` 组件
- 将搜索框插入到标题和窗口按钮之间
- 使用 `Window.setTitleBar(CustomTitleBar(self))` 应用自定义标题栏

### ✨ 功能恢复

- ✅ 搜索框显示在标题栏中间位置
- ✅ 支持输入和清除功能
- ✅ 宽度 400px，居中对齐
- ✅ 占位符文字："搜索应用、游戏、电影、设备等"

### 📝 代码变更

#### 新增 CustomTitleBar 类
```python
class CustomTitleBar(FluentTitleBar):
    """ 带搜索框的标题栏 """

    def __init__(self, parent):
        super().__init__(parent)
        
        # 添加搜索框
        self.searchLineEdit = SearchLineEdit(self)
        self.searchLineEdit.setPlaceholderText('搜索应用、游戏、电影、设备等')
        self.searchLineEdit.setFixedWidth(400)
        self.searchLineEdit.setClearButtonEnabled(True)
        
        # 将搜索框插入到标题和按钮之间
        self.hBoxLayout.insertWidget(2, self.searchLineEdit, 0, Qt.AlignmentFlag.AlignCenter)
        self.hBoxLayout.insertStretch(3, 1)
```

#### Window 类修改
```python
class Window(FluentWindow):
    def __init__(self):
        super().__init__()
        
        # 设置自定义标题栏
        self.setTitleBar(CustomTitleBar(self))
        # ... 其他代码 ...
```

### 🎯 测试验证

- [x] 搜索框正常显示
- [x] 搜索框位置居中
- [x] 可以输入文字
- [x] 清除按钮正常工作
- [x] 深色/浅色主题下正常显示
- [x] 与 FluentWindow 其他功能兼容

---

## v1.3 - 2025-10-20 ⭐ 重大更新

### 🎯 完全参考样式模板实现

**核心改进**：将架构从 `FramelessWindow` 完全迁移到 `FluentWindow`，实现与官方样式模板一致的体验。

### ✨ 重大架构变更

#### 从 FramelessWindow 迁移到 FluentWindow

**旧架构**（v1.2）：
- 使用 `qframelesswindow.FramelessWindow` 作为基类
- 手动创建 `NavigationBar` 和 `StackedWidget`
- 手动管理布局和主题切换
- 需要自定义 TitleBar

**新架构**（v1.3）：
- 使用 `qfluentwidgets.FluentWindow` 作为基类
- 内置导航和堆叠窗口系统
- 自动管理主题和样式
- 内置标准 TitleBar

### 🆕 新增功能

#### 1. 系统主题监听器
- ✅ 使用 `SystemThemeListener` 监听 Windows 系统主题变化
- ✅ "跟随系统设置"模式现在真正有效
- ✅ 系统切换深色/浅色模式时，应用自动跟随
- ✅ 完全参考样式模板的实现方式

#### 2. 启动画面
- ✅ 新增 `SplashScreen` 启动画面
- ✅ 应用启动时显示欢迎界面
- ✅ 提升用户体验

#### 3. Acrylic 导航栏
- ✅ 导航栏启用 Acrylic 半透明效果
- ✅ 更现代化的视觉效果

### 🔧 技术改进

#### 代码简化
```
删除的类和方法：
- CustomTitleBar 类（不再需要）
- StackedWidget 类（FluentWindow 内置）
- initLayout() 方法（自动管理）
- onThemeChanged() 方法（自动处理）
- setQss() 方法（自动应用）

代码行数：
v1.2: 227 行
v1.3: 127 行
减少: 100 行 (44% 简化)
```

#### 主题管理优化
- ✅ 不再需要手动加载 QSS 样式文件
- ✅ FluentWindow 自动管理所有主题样式
- ✅ 深色主题现在完美支持所有组件
- ✅ 主题切换更流畅，无闪烁

### 📋 功能完整性

#### 主题模式
- ✅ 浅色主题 - 完美
- ✅ 深色主题 - 完美（已修复所有问题）
- ✅ 跟随系统设置 - 新增功能

#### 用户界面
- ✅ 导航栏 - 更流畅
- ✅ 窗口控制 - 更稳定
- ✅ Mica 效果 - Win11 支持
- ✅ 启动画面 - 新增
- ✅ Acrylic 效果 - 导航栏

### 🎨 视觉改进

#### 深色主题
- ✅ 窗口背景：自动深色
- ✅ 导航栏：深色 + Acrylic 半透明
- ✅ 标题栏：深色
- ✅ 按钮：自动白色图标
- ✅ 文字：自动白色

#### 浅色主题
- ✅ 窗口背景：自动浅色
- ✅ 导航栏：浅色 + Acrylic 半透明
- ✅ 标题栏：浅色
- ✅ 按钮：自动黑色图标
- ✅ 文字：自动黑色

### 🔄 迁移说明

如果您使用的是 v1.2，升级到 v1.3 后：
- ✅ 所有原有功能保持可用
- ✅ 主题切换更可靠
- ✅ 新增"跟随系统"自动切换
- ✅ 代码更简洁易维护

### 📚 参考文档

详细说明请查看：[v1.3更新说明.md](v1.3更新说明.md)

---

## v1.2 - 2025-10-20

### 🐛 Bug 修复

#### 1. 修复重复的窗口控制按钮
**问题描述**：
- 标题栏出现两组最小化、最大化、关闭按钮
- 原因是先移除了按钮，然后又重新添加

**修复方案**：
- 移除了 `CustomTitleBar` 中重复添加按钮的代码
- 保留 `TitleBar` 基类的默认按钮布局
- 只添加图标、标题和搜索框等自定义元素

#### 2. 修复深色主题背景不生效
**问题描述**：
- 切换到深色主题后，主窗口背景仍然是浅色
- 标题栏背景色不正确

**修复方案**：
- 更新 `resource/light/demo.qss`：添加 `CustomTitleBar` 背景色
- 更新 `resource/dark/demo.qss`：
  - 添加 `CustomTitleBar` 深色背景
  - 移除覆盖性的 `QWidget` 通用样式
  - 调整样式优先级

### 📝 代码变更

#### demo.py - CustomTitleBar
```python
# 删除了这些代码（导致重复按钮的原因）
# self.hBoxLayout.removeWidget(self.minBtn)
# self.hBoxLayout.removeWidget(self.maxBtn)
# self.hBoxLayout.removeWidget(self.closeBtn)
# ... 重新添加按钮的代码 ...
```

#### resource/light/demo.qss
```css
/* 新增 */
CustomTitleBar {
    background-color: rgb(243, 243, 243);
}
```

#### resource/dark/demo.qss
```css
/* 修改：将文字颜色移到 Widget > QLabel */
Widget > QLabel {
    font: 24px 'Segoe UI', 'Microsoft YaHei';
    color: white;  /* 移动到这里 */
}

/* 新增：标题栏深色背景 */
CustomTitleBar {
    background-color: rgb(32, 32, 32);
}

/* 删除：移除通用 QWidget 样式（防止覆盖） */
```

### ✨ 修复后效果

#### 窗口控制按钮
- ✅ 只显示一组按钮（最小化、最大化、关闭）
- ✅ 按钮位置正确（右上角）
- ✅ 按钮样式正确（随主题变化）

#### 深色主题
- ✅ 主窗口背景：深灰色 `rgb(32, 32, 32)`
- ✅ 标题栏背景：深灰色 `rgb(32, 32, 32)`
- ✅ 内容区域背景：深灰色 `rgb(39, 39, 39)`
- ✅ 文字颜色：白色
- ✅ 切换主题后立即生效

#### 浅色主题
- ✅ 主窗口背景：浅灰色 `rgb(243, 243, 243)`
- ✅ 标题栏背景：浅灰色 `rgb(243, 243, 243)`
- ✅ 内容区域背景：浅灰色 `rgb(249, 249, 249)`
- ✅ 文字颜色：黑色

### 🎯 测试验证

#### 测试场景 1：窗口按钮
- [x] 启动应用，只显示一组窗口控制按钮
- [x] 最小化、最大化、关闭功能正常
- [x] 鼠标悬停有正确的高亮效果

#### 测试场景 2：浅色主题
- [x] 主窗口整体为浅色背景
- [x] 标题栏与主窗口颜色一致
- [x] 文字清晰可读

#### 测试场景 3：深色主题
- [x] 设置 → 个性化 → 应用主题 → 深色
- [x] 主窗口立即变为深色背景
- [x] 标题栏同步变为深色
- [x] 窗口控制按钮颜色变为白色
- [x] 所有文字变为白色

#### 测试场景 4：主题切换
- [x] 浅色 ↔ 深色切换流畅
- [x] 所有元素同步更新
- [x] 无闪烁或异常

---

## v1.1 - 2025-10-20

### 🐛 Bug 修复

#### 主题切换问题修复
**问题描述**：
- 在设置界面切换主题时，主界面背景颜色不会自动更新
- 需要重启应用才能看到主题变化效果

**修复内容**：

1. **添加主题变化监听**（demo.py）
   - 在窗口初始化时连接 `cfg.themeChanged` 信号
   - 添加 `onThemeChanged()` 方法，自动重新加载样式表
   - 现在切换主题后立即生效，无需重启

2. **应用启动时加载配置**（demo.py）
   - 启动时立即应用配置中保存的主题
   - 启动时应用配置中保存的主题色
   - 确保应用启动时使用用户上次选择的主题

3. **修改默认主题**（config.py）
   - 将默认主题从 `Theme.AUTO`（跟随系统）改为 `Theme.LIGHT`（浅色）
   - 确保首次启动时使用浅色主题

### 📝 代码变更

#### demo.py
```python
# 新增：应用配置中的主题设置
setTheme(cfg.get(cfg.themeMode))
setThemeColor(cfg.get(cfg.themeColor))

# 新增：连接主题变化信号
cfg.themeChanged.connect(self.onThemeChanged)

# 新增：主题变化回调方法
def onThemeChanged(self, theme: Theme):
    """ 主题变化时重新加载样式 """
    self.setQss()
```

#### config.py
```python
# 修改：默认主题设置
cfg.themeMode.value = Theme.LIGHT  # 从 Theme.AUTO 改为 Theme.LIGHT
```

### ✨ 功能改进

#### 主题切换体验
- ⚡ **即时生效**：切换主题后立即看到效果
- 🎨 **保持一致**：所有界面同步更新主题
- 💾 **自动保存**：主题选择自动保存到配置文件
- 🔄 **启动恢复**：重启应用时恢复上次选择的主题

#### 使用方式
1. 打开应用 → 点击"设置"
2. 个性化 → 应用主题
3. 选择：浅色 / 深色 / 跟随系统设置
4. ✅ 立即看到主界面背景颜色变化

### 🎯 测试验证

#### 测试场景 1：浅色主题
- [x] 启动应用默认为浅色主题
- [x] 主界面背景为白色
- [x] 文字为深色

#### 测试场景 2：切换到深色
- [x] 设置中选择"深色"主题
- [x] 主界面背景立即变为深色
- [x] 文字变为浅色
- [x] 无需重启应用

#### 测试场景 3：跟随系统
- [x] 设置中选择"跟随系统设置"
- [x] 主题跟随系统变化
- [x] 主界面背景正确更新

#### 测试场景 4：重启恢复
- [x] 选择主题后关闭应用
- [x] 重新启动应用
- [x] 主题保持上次选择

### 📖 相关文档更新

无需更新文档，原有使用说明仍然有效。

---

## v1.0 - 2025-10-20

### 🎉 初始发布

#### 核心功能
- ✅ 个性化设置（5项）
- ✅ 材料设置（1项）
- ✅ 配置管理系统
- ✅ 完整的设置界面

详细信息请查看 [README_设置功能.md](README_设置功能.md)

---

**当前版本**: v1.1  
**最后更新**: 2025-10-20
